# -*- coding: utf-8 -*-
"""
Created on Wed Jan 24 2018

@author: Fei Yan
"""

import numpy as np
from scipy.linalg import eig
from qutip import *

import logging
log = logging.getLogger('LabberDriver')

# import scipy.constants as const
# #Constants.
# h = const.h #planck constant
# h_bar = const.hbar #h_bar
# e = const.e #electron charge
# phi0= h/(2*e) #flux quantum
# RQ = h/(2*e)**2 #quantum resistance



def Ej_SQUID(flux,Ej_sum,d):
	# effective Ej of a SQUID
	return Ej_sum * np.abs(np.cos(np.pi*flux)) * np.sqrt(1+d**2*np.tan(np.pi*flux)**2) #[GHz]

def freq_SQUID(Ej, Ec):
	return np.sqrt(8 * Ej *Ec) - Ec

def freq_LC(L,C):
	# frequency of LC oscillator
	# L [nH]
	# C [fH]
	return 1/(2*np.pi)/np.sqrt(L*C)/1e-3   #[GHz]

def Z_LC(L,C):
	# impedence of LC oscillator
	return np.sqrt(L/C)*1e3   #[Ohm]

def U(H,t):
	# unitary propagator generated by H over time t 
	H = Qobj(H)
	return Qobj(-1j * H * t).expm()

def T(A, U, *args, **kwargs):
	A = Qobj(A)
	U = Qobj(U)
	return U * A * U.dag()

def Qflatten(Q):
	return Qobj(Q.full())

def eigensolve(H):
	# find eigensolution of H
	H = H.full()
	vals, vecs = eig(H)    
	#idx = vals.argsort()[::-1] #Descending Order
	idx = vals.argsort() #Ascending Order
	vals = vals[idx]
	vecs = vecs[:,idx]
	return np.real(vals), vecs

def level_identify(vals, vecs, list_table, list_select):
	# identify and sort eigen solutions according to "list_select"
	v_idx = []
	for k, str_level in enumerate(list_select):
		idx_sort = np.argsort(np.abs(vecs[list_table.index(str_level),:]))
		count = 1
		while True:
			if idx_sort[-count] in v_idx:
				count += 1
			else:
				v_idx.append(idx_sort[-count])
				break			
	return vals[v_idx], vecs[:,v_idx]


class Sequence():

	def UNIT_RAMP(t):
		return 1-abs(t)

	def UNIT_COS(t):
		return (1 + np.cos(np.pi*t))/2

	def UNIT_HALFCOS(t):
		return np.cos(np.pi*t)

	def UNIT_GAUSS(t):
		return np.exp(-t**2)


	def add_rise(t, pulseCfg):
		return {
		'ramp': t,
		'cos': (1-np.cos(np.pi*t))/2,
		'halfsin': np.sin(np.pi/2*t),
		'gauss': (np.exp(-((t-1)/0.5)**2) - np.exp(-((1)/0.5)**2)) / (1 - np.exp(-((1)/0.5)**2))
	}[pulseCfg.RISE_SHAPE]

	def add_pulse(t, pulseCfg):
		pulseCfg.START = pulseCfg.PLATEAU_START - pulseCfg.RISE
		pulseCfg.PLATEAU_END = pulseCfg.PLATEAU_START + pulseCfg.PLATEAU
		pulseCfg.END = pulseCfg.PLATEAU_END + pulseCfg.FALL
		if t < pulseCfg.START:
			return 0
		elif pulseCfg.START <= t < pulseCfg.PLATEAU_START:
			return add_rise(t, pulseCfg)
		elif pulseCfg.PLATEAU_START <= t < pulseCfg.PLATEAU_END:
			return add_plateau(t, pulseCfg)
		elif pulseCfg.PLATEAU_END <= t < pulseCfg.END:
			return add_rise(t, pulseCfg)
		elif t >= pulseCfg.END:
			return 0

	def timeFunc_Q1_Z(t, args):
		return

	def timeFunc_Freq_Q1(t, args):
		return

	def timeFunc_Anh_Q1(t, args):
		return

	def timeFunc_Freq_Q2(t, args):
		return

	def timeFunc_Anh_Q2(t, args):
		return

	def timeFunc_Freq_Q3(t, args):
		return

	def timeFunc_Anh_Q3(t, args):
		return

	def timeFunc_g_12(t, args):
		return

	def timeFunc_g_23(t, args):
		return

	def timeFunc_g_13(t, args):
		return	

	def timeFunc_dr_Q1_p(t, args):
		return

	def timeFunc_dr_Q2_p(t, args):
		return

	def timeFunc_dr_Q3_p(t, args):
		return	


class Simulation():

	def generateOperators(self):
		# generate basic operators. matrix truncated at nTrunc 
		I = qeye(self.nTrunc)
		a = destroy(self.nTrunc)
		x = a + a.dag()
		p = -1j*(a - a.dag())
		aa = a.dag() * a
		aaaa = a.dag() * a.dag() * a * a
		return {'I':I, 'a':a, 'x':x, 'p':p, 'aa':aa, 'aaaa':aaaa}

	def generateSubHamiltonian_3Q(self):
		# generate partial Hamiltonian in 3-qubit system
		OP = self.generateOperators()
		# self Hamiltonian operators
		self.H_Q1_aa = Qflatten(tensor(OP['aa'], OP['I'], OP['I']))
		self.H_Q1_aaaa = Qflatten(tensor(OP['aaaa'], OP['I'], OP['I']))
		self.H_Q2_aa = Qflatten(tensor(OP['I'], OP['aa'], OP['I']))
		self.H_Q2_aaaa = Qflatten(tensor(OP['I'], OP['aaaa'], OP['I']))
		self.H_Q3_aa = Qflatten(tensor(OP['I'], OP['I'], OP['aa']))
		self.H_Q3_aaaa = Qflatten(tensor(OP['I'], OP['I'], OP['aaaa']))
		# coupling Hamiltonian operators
		self.H_12_xx = Qflatten(tensor(OP['x'], OP['x'], OP['I']))
		self.H_23_xx = Qflatten(tensor(OP['I'], OP['x'], OP['x']))
		self.H_13_xx = Qflatten(tensor(OP['x'], OP['I'], OP['x']))		#
		self.H_12_pp = Qflatten(tensor(OP['p'], OP['p'], OP['I']))
		self.H_23_pp = Qflatten(tensor(OP['I'], OP['p'], OP['p']))
		self.H_13_pp = Qflatten(tensor(OP['p'], OP['I'], OP['p']))
		# drive Hamiltonian operators
		self.H_dr_Q1_x = Qflatten(tensor(OP['x'], OP['I'], OP['I']))
		self.H_dr_Q2_x = Qflatten(tensor(OP['I'], OP['x'], OP['I']))
		self.H_dr_Q3_x = Qflatten(tensor(OP['I'], OP['I'], OP['x']))
		self.H_dr_Q1_p = Qflatten(tensor(OP['p'], OP['I'], OP['I']))
		self.H_dr_Q2_p = Qflatten(tensor(OP['I'], OP['p'], OP['I']))
		self.H_dr_Q3_p = Qflatten(tensor(OP['I'], OP['I'], OP['p']))
		# collapse operators
		self.L_Q1_a = Qflatten(tensor(OP['a'], OP['I'], OP['I']))
		self.L_Q2_a = Qflatten(tensor(OP['I'], OP['a'], OP['I']))
		self.L_Q3_a = Qflatten(tensor(OP['I'], OP['I'], OP['a']))


	def generateHamiltonian_3Q_cap(self):
		# construct 3-qubit Hamiltonian
		self.generateSubHamiltonian_3Q()
		# self Hamiltonian
		self.H_Q1 = self.dFreq_Q1 * self.H_Q1_aa + self.dAnh_Q1/2 * self.H_Q1_aaaa
		self.H_Q2 = self.dFreq_Q2 * self.H_Q2_aa + self.dAnh_Q2/2 * self.H_Q2_aaaa
		self.H_Q3 = self.dFreq_Q3 * self.H_Q3_aa + self.dAnh_Q3/2 * self.H_Q3_aaaa
		# coupling Hamiltonian
		self.g_12 = 0.5 * self.c12 * np.sqrt(self.dFreq_Q1 * self.dFreq_Q2)
		self.H_12 = self.g_12 * self.H_12_pp
		self.g_23 = 0.5 * self.c23 * np.sqrt(self.dFreq_Q2 * self.dFreq_Q3)
		self.H_23 = self.g_23 * self.H_23_pp
		self.g_13 = 0.5 * (self.c12 * self.c23 + self.c13) * np.sqrt(self.dFreq_Q1 * self.dFreq_Q3)
		self.H_13 = self.g_13 * self.H_13_pp
		# system Hamiltonian
		self.H_sys = self.H_Q1 + self.H_Q2 + self.H_Q3 + self.H_12 + self.H_23 + self.H_13


	def generateCollapse_3Q(self):
		self.c_ops = [np.sqrt(self.Gamma1_Q1) * L_Q1_a,
					 np.sqrt(self.Gamma1_Q2) * L_Q2_a,
					 np.sqrt(self.Gamma1_Q3) * L_Q3_a]


	def rhoEvolver_3Q(self, rho0):
		#
		result = mesolve(H=[
			[self.H_Q1_aa, self.sequence.timeFunc_Freq_Q1],
			[self.H_Q1_aaaa, self.sequence.timeFunc_Anh_Q1],
			[self.H_Q2_aa, self.sequence.timeFunc_Freq_Q2],
			[self.H_Q2_aaaa, self.sequence.timeFunc_Anh_Q2],
			[self.H_Q3_aa, self.sequence.timeFunc_Freq_Q3],
			[self.H_Q3_aaaa, self.sequence.timeFunc_Anh_Q3],
			[self.H_12_pp, self.sequence.timeFunc_g_12],
			[self.H_23_pp, self.sequence.timeFunc_g_23],
			[self.H_13_pp, self.sequence.timeFunc_g_13],
			[self.H_dr_Q1_p, self.sequence.timeFunc_dr_Q1_p],
			[self.H_dr_Q2_p, self.sequence.timeFunc_dr_Q2_p],
			[self.H_dr_Q3_p, self.sequence.timeFunc_dr_Q3_p]
			],
			rho0 = rho0, tlist = self.tlist, c_ops = self.c_ops, args = self)#, options = options), store_states=True, c_ops=[], e_ops=[]
		return result.states


	def simulateEvolution_3Q(rho_input_rot):
		#
		self.generateHamiltonian_3Q_cap()
		self.generateCollapse_3Q()
		self.tlist = np.linspace(self.dTimeStart, self.dTimeEnd, self.nTimeList)
		self.rho_input_lab = T(rho_input_rot, U(self.H_sys, t_start))
		self.sequence = Sequence()
		self.rhoEvolver_3Q(rho0)
		#
		t_start = 0.0
		t_end = args['t_shift_start'] + args['t_shift_rise'] + args['t_shift_plateau'] + args['t_shift_fall']
		
		rho_input_lab = U(H_idle,t_start) * rho_input_rot * U(H_idle,t_start).dag()
		result_rhos = sim_PRESS(rho_input_lab, times, args, c_ops)
		# states = np.zeros((n_states,n_times), dtype=complex)
		# p_states = np.zeros((n_states,n_times))
		# for i_t,time in enumerate(times):
		# 	state_lab = result_rhos[i_t]
		# 	state_rot = U(H_idle,time).dag() * state_lab
		# 	for i_s in np.arange(n_states):
		# 		states[i_s,i_t] = state_rot.overlap(Qobj(vecs_select[:,i_s]))
		# 		p_states[i_s,i_t] = np.abs(states[i_s,i_t])**2
		print("elapsed:", timeit_end - timeit_start)
		rho_output_rot = U(H_idle,t_end).dag() * result_rhos[-1] * U(H_idle,t_end)
		return rho_output_rot  #times, states, p_states

class MultiQubitHamiltonian():

	def __init__(self):
		# init with some default settings
		self.nQubit = 3
		self.nTrunc = 4
		self.nShow = 4
		self.bDesignParam_Q1 = False
		self.bDesignParam_Q2 = False
		self.bDesignParam_Q3 = False
		self.sQubitType_Q1 = '2-JJ'
		self.sQubitType_Q2 = '2-JJ'
		self.sQubitType_Q3 = '2-JJ'
		# frequencies [GHz]
		self.dFreq_Q1 = 4.0
		self.dFreq_Q2 = 4.0
		self.dFreq_Q3 = 4.0
		self.dAnh_Q1 = -0.3
		self.dAnh_Q2 = -0.3
		self.dAnh_Q3 = -0.3
		# capacitances [fF]
		self.dC1 = 80.0
		self.dC2 = 80.0
		self.dC3 = 80.0
		self.dC12 = 1.0
		self.dC23 = 1.0
		self.dC13 = 0.02
		# inductances [nH]
		#
		# designer parameter set
		# josephson energy [GHz]
		self.dEj_Q1 = 10.0
		self.dEj_Q2 = 10.0
		self.dEj_Q3 = 10.0
		# charging energy [GHz]
		self.dEc_Q1 = 0.2
		self.dEc_Q2 = 0.2
		self.dEc_Q3 = 0.2
		# SQUID asymmetry |A1-A2|/(A1+A2)
		self.dAsym_Q1 = 0.0
		self.dAsym_Q2 = 0.0
		self.dAsym_Q3 = 0.0
		# flux bias [Phi0]
		self.dFlux_Q1 = 0.0
		self.dFlux_Q2 = 0.0
		self.dFlux_Q3 = 0.0
		# #
		# # calculate partial coupling coefficients (approximate)
		# self.c12 = self.dC12 / np.sqrt(self.dC1 * self.dC2)
		# self.c23 = self.dC23 / np.sqrt(self.dC2 * self.dC3)
		# self.c13 = self.dC13 / np.sqrt(self.dC1 * self.dC3)
		# #
		# if simCfg is not None:
		# 	# update simulation options
		# 	self.updateSimCfg(simCfg)


	def updateSimCfg(self, simCfg):
		# update simulation options
		for key, value in simCfg.items():
			if hasattr(self, key):
				setattr(self, key, value)
		# update capacitance coupling coefficient
		self.c12 = self.dC12 / np.sqrt(self.dC1 * self.dC2)
		self.c23 = self.dC23 / np.sqrt(self.dC2 * self.dC3)
		self.c13 = self.dC13 / np.sqrt(self.dC1 * self.dC3)
		# update frequencies if using designer parameter set
		if self.bDesignParam_Q1:
			if self.sQubitType_Q1 == '2-JJ':
				setattr(self, 'dFreq_Q1', freq_SQUID(Ej_SQUID(self.dFlux_Q1,self.dEj_Q1,self.dAsym_Q1), self.dEc_Q1))
				setattr(self, 'dAnh_Q1', -self.dEc_Q1)
		if self.bDesignParam_Q2:
			if self.sQubitType_Q2 == '2-JJ':
				setattr(self, 'dFreq_Q2', freq_SQUID(Ej_SQUID(self.dFlux_Q2,self.dEj_Q2,self.dAsym_Q2), self.dEc_Q2))
				setattr(self, 'dAnh_Q2', -self.dEc_Q2)
		if self.bDesignParam_Q3:
			if self.sQubitType_Q3 == '2-JJ':
				setattr(self, 'dFreq_Q3', freq_SQUID(Ej_SQUID(self.dFlux_Q3,self.dEj_Q3,self.dAsym_Q3), self.dEc_Q3))
				setattr(self, 'dAnh_Q3', -self.dEc_Q3)


	def generateOperators(self):
		# generate basic operators. matrix truncated at nTrunc 
		I = qeye(self.nTrunc)
		a = destroy(self.nTrunc)
		x = a + a.dag()
		p = -1j*(a - a.dag())
		aa = a.dag() * a
		aaaa = a.dag() * a.dag() * a * a
		return {'I':I, 'a':a, 'x':x, 'p':p, 'aa':aa, 'aaaa':aaaa}


	def generateSubHamiltonian_1Q(self):
		# generate partial Hamiltonian in 3-qubit system
		OP = self.generateOperators()
		# self Hamiltonian operators
		self.H_Q1_aa = Qflatten(tensor(OP['aa']))
		self.H_Q1_aaaa = Qflatten(tensor(OP['aaaa']))
		# drive Hamiltonian operators
		self.H_dr_Q1_x = Qflatten(tensor(OP['x']))
		self.H_dr_Q1_p = Qflatten(tensor(OP['p']))


	def generateHamiltonian_1Q_cap(self):
		# construct 3-qubit Hamiltonian
		self.generateSubHamiltonian_1Q()
		# self Hamiltonian
		self.H_Q1 = self.dFreq_Q1 * self.H_Q1_aa + self.dAnh_Q1/2 * self.H_Q1_aaaa
		# system Hamiltonian
		self.H_sys = self.H_Q1 + self.H_Q2 + self.H_12


	def generateLabel_1Q(self):
		# generate 3-qubit number state label list
		list_label_gen = ["0","1","2","3","4","5","6","7"]
		self.list_label_table = []
		for k1 in np.arange(self.nTrunc):
			self.list_label_table.append(list_label_gen[k1])


	def generateSubHamiltonian_2Q(self):
		# generate partial Hamiltonian in 3-qubit system
		OP = self.generateOperators()
		# self Hamiltonian operators
		self.H_Q1_aa = Qflatten(tensor(OP['aa'], OP['I']))
		self.H_Q1_aaaa = Qflatten(tensor(OP['aaaa'], OP['I']))
		self.H_Q2_aa = Qflatten(tensor(OP['I'], OP['aa']))
		self.H_Q2_aaaa = Qflatten(tensor(OP['I'], OP['aaaa']))
		# coupling Hamiltonian operators
		self.H_12_xx = Qflatten(tensor(OP['x'], OP['x']))#
		self.H_12_pp = Qflatten(tensor(OP['p'], OP['p']))
		# drive Hamiltonian operators
		self.H_dr_Q1_x = Qflatten(tensor(OP['x'], OP['I']))
		self.H_dr_Q2_x = Qflatten(tensor(OP['I'], OP['x']))
		self.H_dr_Q1_p = Qflatten(tensor(OP['p'], OP['I']))
		self.H_dr_Q2_p = Qflatten(tensor(OP['I'], OP['p']))


	def generateHamiltonian_2Q_cap(self):
		# construct 3-qubit Hamiltonian
		self.generateSubHamiltonian_2Q()
		# self Hamiltonian
		self.H_Q1 = self.dFreq_Q1 * self.H_Q1_aa + self.dAnh_Q1/2 * self.H_Q1_aaaa
		self.H_Q2 = self.dFreq_Q2 * self.H_Q2_aa + self.dAnh_Q2/2 * self.H_Q2_aaaa
		# coupling Hamiltonian
		self.g_12 = 0.5 * self.c12 * np.sqrt(self.dFreq_Q1 * self.dFreq_Q2)
		self.H_12 = self.g_12 * self.H_12_pp
		# system Hamiltonian
		self.H_sys = self.H_Q1 + self.H_Q2 + self.H_12


	def generateLabel_2Q(self):
		# generate 3-qubit number state label list
		list_label_gen = ["0","1","2","3","4","5","6","7"]
		self.list_label_table = []
		for k1 in np.arange(self.nTrunc):
			for k2 in np.arange(self.nTrunc):
				self.list_label_table.append(list_label_gen[k1] + list_label_gen[k2])


	def generateSubHamiltonian_3Q(self):
		# generate partial Hamiltonian in 3-qubit system
		OP = self.generateOperators()
		# self Hamiltonian operators
		self.H_Q1_aa = Qflatten(tensor(OP['aa'], OP['I'], OP['I']))
		self.H_Q1_aaaa = Qflatten(tensor(OP['aaaa'], OP['I'], OP['I']))
		self.H_Q2_aa = Qflatten(tensor(OP['I'], OP['aa'], OP['I']))
		self.H_Q2_aaaa = Qflatten(tensor(OP['I'], OP['aaaa'], OP['I']))
		self.H_Q3_aa = Qflatten(tensor(OP['I'], OP['I'], OP['aa']))
		self.H_Q3_aaaa = Qflatten(tensor(OP['I'], OP['I'], OP['aaaa']))
		# coupling Hamiltonian operators
		self.H_12_xx = Qflatten(tensor(OP['x'], OP['x'], OP['I']))
		self.H_23_xx = Qflatten(tensor(OP['I'], OP['x'], OP['x']))
		self.H_13_xx = Qflatten(tensor(OP['x'], OP['I'], OP['x']))		#
		self.H_12_pp = Qflatten(tensor(OP['p'], OP['p'], OP['I']))
		self.H_23_pp = Qflatten(tensor(OP['I'], OP['p'], OP['p']))
		self.H_13_pp = Qflatten(tensor(OP['p'], OP['I'], OP['p']))
		# drive Hamiltonian operators
		self.H_dr_Q1_x = Qflatten(tensor(OP['x'], OP['I'], OP['I']))
		self.H_dr_Q2_x = Qflatten(tensor(OP['I'], OP['x'], OP['I']))
		self.H_dr_Q3_x = Qflatten(tensor(OP['I'], OP['I'], OP['x']))
		self.H_dr_Q1_p = Qflatten(tensor(OP['p'], OP['I'], OP['I']))
		self.H_dr_Q2_p = Qflatten(tensor(OP['I'], OP['p'], OP['I']))
		self.H_dr_Q3_p = Qflatten(tensor(OP['I'], OP['I'], OP['p']))


	def generateHamiltonian_3Q_cap(self):
		# construct 3-qubit Hamiltonian
		self.generateSubHamiltonian_3Q()
		# self Hamiltonian
		self.H_Q1 = self.dFreq_Q1 * self.H_Q1_aa + self.dAnh_Q1/2 * self.H_Q1_aaaa
		self.H_Q2 = self.dFreq_Q2 * self.H_Q2_aa + self.dAnh_Q2/2 * self.H_Q2_aaaa
		self.H_Q3 = self.dFreq_Q3 * self.H_Q3_aa + self.dAnh_Q3/2 * self.H_Q3_aaaa
		# coupling Hamiltonian
		self.g_12 = 0.5 * self.c12 * np.sqrt(self.dFreq_Q1 * self.dFreq_Q2)
		self.H_12 = self.g_12 * self.H_12_pp
		self.g_23 = 0.5 * self.c23 * np.sqrt(self.dFreq_Q2 * self.dFreq_Q3)
		self.H_23 = self.g_23 * self.H_23_pp
		self.g_13 = 0.5 * (self.c12 * self.c23 + self.c13) * np.sqrt(self.dFreq_Q1 * self.dFreq_Q3)
		self.H_13 = self.g_13 * self.H_13_pp
		# system Hamiltonian
		self.H_sys = self.H_Q1 + self.H_Q2 + self.H_Q3 + self.H_12 + self.H_23 + self.H_13


	def generateLabel_3Q(self):
		# generate 3-qubit number state label list
		list_label_gen = ["0","1","2","3","4","5","6","7"]
		self.list_label_table = []
		for k1 in np.arange(self.nTrunc):
			for k2 in np.arange(self.nTrunc):
				for k3 in np.arange(self.nTrunc):
					self.list_label_table.append(list_label_gen[k1] + list_label_gen[k2] + list_label_gen[k3])



class Noise():